import os
def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

import sys
def main():
    if len(sys.argv) < 2:
        print("No level loaded.")
        return

    with open(sys.argv[1], encoding='utf-8') as File:
        Level = File.readlines()
        for i in range(len(Level)-1):
            Level[i] = Level[i][0:-1]
        Play(Level)
        return

from time import sleep
 
Description={
    "Axe": "Move to a tree to cut it down.",
    "Flamethrower": "Move to a tree to burn it and all nearby trees."
    }

# Readability of r,c functions
(r,c)=(0,1)

Ascii={
    ".":    "Floor",
    "L":    "Player",
    "T":    "Tree",
    "+":    "Mushroom",
    "R":    "Rock",
    "~":    "Water",
    "_":    "Paved",
    "x":    "Axe",
    "*":    "Flamethrower",
    "Floor":        '.',
    "Player":       'L',
    "Tree":         'T',
    "Mushroom":     '+',
    "Rock":         'R',
    "Water":        '~',
    "Paved":        '_',
    "Axe":          'x',
    "Flamethrower": '*'}

# Use to get graphics and to convert ASCII to UI
Ui={
    ".": '  ',
    "L": '🧑',
    "T": '🌲',
    "+": '🍄',
    "R": '🪨',
    "~": '🟦',
    "_": '⬜',
    "x": '🪓',
    "*": '🔥',
    "Floor": ' ',
    "Player": '🧑',
    "Tree": '🌲',
    "Mushroom": '🍄',
    "Rock": '🪨',
    "Water": '🟦',
    "Paved": '⬜',
    "Axe": '🪓',
    "Flamethrower": '🔥'}

# Include all valid keys in its controls tuple
Up=     ('w','u') + ('i',)
Left=   ('a','l') + ('j',)
Down=  ('s',)   + ('k',)
Right=   ('d','r') + ('l',)
Pickup= ('p',)
Reset=  ('!',)

Valid = Up+Left+Right+Down+Pickup+Reset

# String grid (list of strings):
    # levels are stored (.txt) and displayed this way
    
# Tile grid (list of list of chars):
    # used as the game is running to quickly edit tiles


def StringGridToTileGrid(grid):
    for i in range(len(grid)):
        grid[i] = list(t for t in grid[i])
    return grid

def TileGridToStringGrid(grid):
    return list("".join(grid[i]) for i in range(len(grid)))
        

# ex. get all Rock positions: FindAll(Grid, Ascii["Player"])
# Must be a tile grid
def FindAll(grid, item):
    positions=[]
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == item:
                positions.append( (i,j) )
    return positions

# Recursively check a tree's neighbors for other trees
# in order to burn them: modifies the grid data
def BurnTrees(grid, positions):
    next_positions=[]
    for position in positions:
        (i,j)=position
        if grid[i][j] == Ascii["Tree"]:
            grid[i][j] = Ascii["Floor"]

            if i>0:
                if grid[i-1][j] == Ascii["Tree"]:
                    next_positions.append( (i-1,j) )

            if i<len(grid)-1:
                if grid[i+1][j] == Ascii["Tree"]:
                    next_positions.append( (i+1,j) )

            if j>0:
                if grid[i][j-1] == Ascii["Tree"]:
                    next_positions.append( (i,j-1) )

            if j<len(grid[0])-1:
                if grid[i][j+1] == Ascii["Tree"]:
                    next_positions.append( (i,j+1) )

    if next_positions!=[]:
        return BurnTrees(grid, next_positions)
    else:
        return grid
    

# Many underlying code kinda hurts my eyes so I abstracted a lot of them here

# Would otherwise look like grid[pos[r]][pos[c]] but eugh
# Used to check valid rock and player moves
def GetGraphicAt(grid, position):
    (r,c)=position
    return grid[r][c]

def Offset(position, offset):
    (r,c)=offset
    return (position[0]+r, position[1]+c)
    

def Play(InitialGrid):
    # Convert from string grid to tile grid
    # Save the initial grid data for resets
    InitialGrid = StringGridToTileGrid(InitialGrid)
    Grid = InitialGrid
    GridWidth, GridHeight = (len(Grid[0]), len(Grid))

    # The player is stored as their coordinates
    # The actual grid data is 'playerless',
    # but the player coordinates are always valid (on top of floor/paved)
    # to check for being on top of items and to keep paved tiles
    PlayerPosition = FindAll(Grid, Ascii["Player"])[0]
    Grid [PlayerPosition[r]] [PlayerPosition[c]] = Ascii["Floor"]

    # Rocks can be pushed on top of paved tiles
    # So we can use the same methods to make the grid data 'rockless'
    # and ensure rock and player positions are always valid
    RockPositions = FindAll(Grid, Ascii["Rock"])
    for RockPosition in RockPositions:
        Grid [RockPosition[r]] [RockPosition[c]] = Ascii["Floor"]
    
    IsComplete = False
    MushroomsCollected = 0
    MaxMushrooms = len(FindAll(Grid, Ascii["Mushroom"]))
    
    HeldItem = None
    OnTopOfItem = None

    while not IsComplete:
        clear()
        
        # Display the grid
        for i in range(0, GridHeight):
            for j in range(0, GridWidth):

                # Display player
                if (i,j) == PlayerPosition:
                    print(Ui["Player"],end="")
                    
                    # Check for items
                    if Grid[i][j] == Ascii["Axe"]:
                        OnTopOfItem = "Axe"
                    elif Grid[i][j] == Ascii["Flamethrower"]:
                        OnTopOfItem = "Flamethrower"
                    else:
                        OnTopOfItem = None

                # Display rocks
                elif (i,j) in RockPositions:
                    print(Ui["Rock"],end="")

                # Display everything else as is
                else:
                    print(Ui[Grid[i][j]], end="")
            print("\n",end="")

        print("\nCollected ", MushroomsCollected," shrooms ["+Ascii["Mushroom"]+"]")
        
        if HeldItem != None:
            print("Holding ", HeldItem)
            print("\t[", Description[HeldItem], "]")

        print("[WASD] Move")
        if OnTopOfItem != None:
            if HeldItem == None:
                print("[P"+Ascii[OnTopOfItem]+"] Pick up ", OnTopOfItem.lower())
            else:
                print("["+Ascii[OnTopOfItem]+"] On top of ", OnTopOfItem.lower())

        print("player at",PlayerPosition)

        PrintInputDebug=False 
        # Input
        print("\nMake move/s: ",end="")
        input_is_valid = False
        while not input_is_valid:
            input_is_valid = True
            steps = list(i.lower() for i in input())

            # check input is valid
            for step in steps:
                if step not in Valid:
                    input_is_valid = False
                    break
        
        print("")
        print(steps)
        
        # for each step in input: apply, check state after
        for Step in steps:

            if Step in Reset:
                pass

            elif Step in Pickup:
                if (HeldItem == None) and (OnTopOfItem != None):
                    (i,j) = PlayerPosition
                    HeldItem = OnTopOfItem
                    Grid[i][j] = Ascii["Floor"]

            else:
                TargetTile = PlayerPosition
                AheadOfTargetTile = PlayerPosition

                # To not have 4 copies, the code works independent of direction
                # Player moves to a "target tile", considering the tile "ahead" of it
                # We find the target tiles by modifying player position
                # ex. to move up, the target tile is player position, but y-1 or row number minus 1
                
                if Step in Up:
                    TargetTile = Offset(PlayerPosition, (-1,0))
                    AheadOfTargetTile = Offset(PlayerPosition, (-2,0))
                    
                elif Step in Down:
                    TargetTile = Offset(PlayerPosition, (1,0))
                    AheadOfTargetTile = Offset(PlayerPosition, (2,0))
                    
                elif Step in Right:
                    TargetTile = Offset(PlayerPosition, (0,1))
                    AheadOfTargetTile = Offset(PlayerPosition, (0,2))

                elif Step in Left:
                    TargetTile = Offset(PlayerPosition, (0,-1))
                    AheadOfTargetTile = Offset(PlayerPosition, (0,-2))


                GoOutOfBounds=True
                if 0<=TargetTile[0]<GridHeight and 0<=TargetTile[1]<GridWidth:
                    GoOutOfBounds=False

                if GoOutOfBounds:
                    continue

                PushOutOfBounds=True
                if 0<=TargetTile[0]<GridHeight and 0<=TargetTile[1]<GridWidth:
                    PushOutOfBounds=False

                
                TargetTileGraphic = GetGraphicAt(Grid, TargetTile)
                AheadOfTargetTileGraphic=None
                (i,j) = AheadOfTargetTile
                if 0<=i<GridHeight and 0<=j<GridWidth:
                    AheadOfTargetTileGraphic = GetGraphicAt(Grid, AheadOfTargetTile)

                # Attempting to push a rock...
                if TargetTile in RockPositions:

                    PushIntoAnotherRock = AheadOfTargetTile in RockPositions
                    PushIntoUnpushable = GetGraphicAt(Grid, AheadOfTargetTile) in [Ascii["Tree"], Ascii["Rock"], Ascii["Mushroom"], Ascii["Axe"], Ascii["Flamethrower"]]

                    # ...onto another rock
                    if PushIntoAnotherRock or PushIntoUnpushable:
                        continue

                    # ...onto floor or paved tile
                    elif AheadOfTargetTileGraphic in [Ascii["Floor"], Ascii["Paved"]]:
                        MovedRock = RockPositions.index(TargetTile)
                        RockPositions[MovedRock] = AheadOfTargetTile
                        PlayerPosition = TargetTile
                    
                    # ...into water
                    elif GetGraphicAt(Grid, AheadOfTargetTile) == Ascii["Water"]:
                        (i,j) = AheadOfTargetTile
                        Grid[i][j] = Ascii["Paved"]

                        RemovedRock = RockPositions.index(TargetTile)
                        PlayerPosition = RockPositions.pop(RemovedRock)

                    else:
                        pass

                # Attempting to go into a mushroom (scores)
                elif TargetTileGraphic == Ascii["Mushroom"]:
                    (i,j) = TargetTile
                    Grid[i][j] = Ascii["Floor"]
                    
                    PlayerPosition = TargetTile
                    MushroomsCollected += 1

                    
                elif TargetTileGraphic == Ascii["Tree"]:
                    if HeldItem == None:
                        print("mamaz that's a tree")

                    elif HeldItem == "Axe":
                        (i,j) = TargetTile
                        Grid[i][j] = Ascii["Floor"]
                        PlayerPosition = TargetTile
                        HeldItem = None

                    elif HeldItem == "Flamethrower":
                        Grid = BurnTrees(Grid, [TargetTile,])
                        HeldItem = None
                        PlayerPosition = TargetTile

                # Attempting to go into floor or paved (works as is)
                elif TargetTileGraphic in [Ascii["Floor"], Ascii["Paved"], Ascii["Axe"], Ascii["Flamethrower"]]:
                    PlayerPosition = TargetTile

                # Attempting to go into water (cause failstate)
                elif TargetTileGraphic in [Ascii["Water"]]:
                    IsComplete=True

        if MushroomsCollected == MaxMushrooms:
            IsComplete=True
    print("either u've collected all shrooms or u fell into water if u see this...")
main()
